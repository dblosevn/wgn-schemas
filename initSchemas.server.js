import path from 'path';
import fs from 'fs';
import { pathToFileURL } from 'url';
import { compileSchemas, schemaPromise, schemaResolve, schemaReject, wmSchemas, frontendOnly, WALGREENS, WORKMARKET, colMeta, wgnSchemas, initResolve, initReject, initPromise, dbModel } from './initSchemas.shared.js';

const __dirname = path.dirname(decodeURI(new URL(import.meta.url).pathname).replace(/^\/([a-zA-Z]:)/, '$1'));
let schemaStarted = false;

/**
 * @type {Promise<import('rxdb').RxDatabase>}
 */
let dbInstance = null;


export async function initSchemas() {
  if (schemaStarted) return schemaPromise;
  schemaStarted = true;

  try {
    const schemaBase = path.resolve(__dirname, "schemas");
    const colDirs = fs.readdirSync(schemaBase);
    const collections = {};

    for (const colDir of colDirs) {
      const colPath = path.join(schemaBase, colDir);
      const migDir = path.join(colPath, "Migrations");

      if (!fs.existsSync(migDir)) {
        fs.mkdirSync(migDir);
      }

      const schFiles = fs.readdirSync(colPath).filter(d => d !== "Migrations");
      const migrations = {};
      let collectionKey = `${colDir.toLowerCase()}s`;
      collectionKey = (collectionKey == 'caches') ? 'cache' : collectionKey;

      const collection = (collections[collectionKey] = {
        name: collectionKey,
        srcServer: (wmSchemas.indexOf(collectionKey) === -1) ? WALGREENS : WORKMARKET,
        schema: null,
        migrations,
        frontendOnly: frontendOnly.indexOf(collectionKey) !== -1,
        meta: colMeta[collectionKey] || null,
        versions: {},
      });

      for (const schFile of schFiles) {
        const filePath = path.join(colPath, schFile);
        const current = (await import(/* @vite-ignore */ pathToFileURL(filePath))).default;

        if (current?.version === undefined || current?.version === null) {
          throw new Error(`Schema file "${schFile}" is missing a version`);
        }

        collection.versions[current.version] = current;
        collection.schema = current;
      }

      const migFiles = fs.readdirSync(migDir).sort((a, b) => {
        const aVer = parseInt(/V(\d+)/.exec(a)?.[1] ?? 0, 10);
        const bVer = parseInt(/V(\d+)/.exec(b)?.[1] ?? 0, 10);
        return aVer - bVer;
      });

      for (const migFile of migFiles) {
        const match = /V([0-9]+)Migration/.exec(migFile);
        if (!match) continue;
        const v = match[1];
        const migPath = pathToFileURL(path.join(migDir, migFile));
        migrations[v] = (await import(/* @vite-ignore */ migPath)).default;
      }
    }

    compileSchemas(collections);
    fs.writeFileSync(path.join(__dirname, 'allschemas.js'), toESMModule(collections, 2));

    schemaResolve(collections);
  } catch (e) {
    schemaReject(e);
  }
  return schemaPromise;
};

function toESMModule(obj, indent = 2) {
  const seen = new WeakMap();

  function serialize(value, depth = 0, path = '') {
    const pad = (n = 0) => ' '.repeat(n * indent);

    if (value === null) return 'null';
    if (typeof value === 'string') return JSON.stringify(value);
    if (typeof value === 'number' || typeof value === 'boolean') return String(value);
    if (typeof value === 'function') return value.toString();

    if (Array.isArray(value)) {
      return `[\n${value.map((v, i) => pad(depth + 1) + serialize(v, depth + 1, `${path}[${i}]`)).join(',\n')}\n${pad(depth)}]`;
    }

    if (typeof value === 'object') {
      if (seen.has(value)) {
        const firstPath = seen.get(value);
        // Treat only true cycles as circular
        if (firstPath === path) {
          return '{} /* [Circular: ' + path + '] */';
        }
        // Otherwise, clone object again normally
      } else {
        seen.set(value, path);
      }

      const entries = Object.entries(value).map(([k, v]) =>
        `${pad(depth + 1)}${JSON.stringify(k)}: ${serialize(v, depth + 1, path ? `${path}.${k}` : k)}`
      );
      return `{\n${entries.join(',\n')}\n${pad(depth)}}`;
    }

    return 'undefined';
  }

  return `// Auto-generated by schema build step\nexport default ${serialize(obj)};\n`;
}

/**
 * @typedef {'walgreens' | 'workmarket'} Server
 * A server identifier, must be either 'walgreens' or 'workmarket'.
 */

/**
 * Initializes the RxDB instance for the given server.
 *
 * @param {Server} server - Server key ('walgreens' or 'workmarket')
 * @param {import('http').Server|null} [http=null] - HTTP server for socket setup
 * @returns {Promise<import('rxdb').RxDatabase>}
 */
export async function initDB(server, http = null, router = null) {
  if (dbInstance) return dbInstance;

  if (!server && !dbInstance) throw new Error('No DB instance and no config');
  console.log(router);
  try {
    await initSchemas();

    const schemas = (server === WALGREENS) ? wgnSchemas : wmSchemas;

    const { createRxDatabase } = await import("rxdb");
    const { addRxPlugin } = await import('rxdb/plugins/core');
    const { getRxStorageMongoDB } = await import("rxdb/plugins/storage-mongodb");
    const { RxDBMigrationSchemaPlugin } = await import('rxdb/plugins/migration-schema');
    const { RxDBUpdatePlugin } = await import('rxdb/plugins/update');
    const process = await import("process");
    const path = await import("path");
    if (!process.env.MONGOURL) {
      const dotenv = await import('dotenv');
      dotenv.config({ path: path.resolve(path.join('../', '.env')) }); //running in standalone mode
    }

    addRxPlugin(RxDBMigrationSchemaPlugin);
    addRxPlugin(RxDBUpdatePlugin);

    const uri = process.env.MONGOURL;
    const db = await createRxDatabase({
      name: server,
      multiInstance: true,
      eventReduce: true,
      storage: getRxStorageMongoDB({ connection: uri })
    });
    let colOptions = {}
    for (let entry of schemas) {
      if (entry.frontendOnly) continue;
      colOptions[entry.name] = {
        schema: entry.schema,
        migrationStrategies: entry.migrations
      }
      if (entry.meta) {
        colOptions[entry.name] = Object.assign(colOptions[entry.name], entry.meta);
      }
    }
    await db.addCollections(colOptions);

    if (server === WALGREENS) {
      const { ServerSocket } = await import("./sockets/serversocket.js");
      await ServerSocket.initialize(db, http, router, true);
    } else if (server === WORKMARKET) {
      const { ServerSocketClient } = await import("./sockets/serversocket.js");
      new ServerSocketClient(process.env.SERVER_PORT, server, db);
    }

    dbInstance = db;
    return initResolve(db);
  } catch (err) {
    return initReject(err);
  }
}


/**
 * Returns an object with the initialized RxDB instance and each collection as PascalCase keys.
 * Waits until initDB is called.
 *
 * @returns {Promise<{ db: import('rxdb').RxDatabase } & Record<string, import('rxdb').RxCollection>>}
 */
export async function getDb() {
  const db = await initPromise;
  return dbModel(db);
}

export async function initWalgreensDB(http, router) {
  return initDB(WALGREENS, http, router);
}
export async function initWorkmarketDB(http, router) {
  return initDB(WORKMARKET, http, router);
}
